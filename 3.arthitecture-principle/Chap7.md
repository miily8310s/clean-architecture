# 第７章 SRP:単一責任の原則

- **単一責任の原則(SRP)**：モジュールはたったひとつのアクターに対して責務を負うべき
- アクター：変更を望む人たちをひとまとめにしたグループ
- モジュール：いくつかの関数やデータをまとめた凝集性のあるもの
- **単一責任の原則(SRP)**の理解には、この原則に違反した例を見るのが一番

## 症例１：想定外の重複

- 給与システムにおける`Employee`クラスを例に上げる
- このクラスは**単一責任の原則(SRP)**に違反している
- クラス内の３メソッドがそれぞれ別々のアクターに対する責務を負っているから
  - `calculatePay()`メソッド：経理部門が規定する。報告先は CFO
  - `reportHours()`メソッド：経理部門が規定する。報告先は CFO
  - `save()`メソッド：経理部門が規定する。報告先は CFO
- **単一責任の原則(SRP)**：**アクターの異なるコードは分割するべき**という法則

## 症例２：マージ

- CTO 配下のチームが`Employee`テーブルのスキーマを変更することになった一方、COO 配下の事務員も、勤怠報告の書式変更が必要になったとする
- 別々の開発チームが、それぞれ個別に変更する
- 変更が衝突してしまうので、最終的にはマージが必要になる
- これだと CTO/COO、CFO までリスクを負う可能性がある
- こうした問題の回避にも、**アクターの異なるコードは分割するべき**

## 解決策

- 関数を別のクラスに移動する、いろんな解決策がある
- 一番わかりやすいのは、データを関数から切り離す方法

## 補足

<!-- @see https://postd.cc/solid-principles-every-developer-should-know/ -->

**単一責任の原則(SRP)**：

- クラスは 1 つのことだけ責任を負うべき
- もし原則に違反して複数の責任を負っているなら、1 つの責任への変更が、他の責任への変更をもたらしてしまう
- ※クラスだけでなく、ソフトウェアコンポーネントにも当てはまる法則

### 例

次の `Animal` クラスは、SRP に違反している。
コンストラクタと `getAnimalName` は `Animal` プロパティを管理し、`saveAnimal` はデータベース上の `Animal` ストレージを管理している。

```ts
class Animal {
  constructor(name: string) {}
  getAnimalName() {}
  saveAnimal(a: Animal) {}
}
```

SRP に一致させるため、データベースに `Animal` を格納する単一の責任を負う別のクラスを生成。

```ts
class Animal {
  constructor(name: string) {}
  getAnimalName() {}
}
class AnimalDB {
  getAnimal(a: Animal) {}
  saveAnimal(a: Animal) {}
}
```
